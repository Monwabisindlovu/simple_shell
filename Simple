#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>

#define MAX_INPUT_SIZE 1024

/**
 * print_prompt - Displays the shell prompt.
 */
void print_prompt(void)
{
    const char msg[] = "$ ";
    write(STDOUT_FILENO, msg, sizeof(msg) - 1);
}

/**
 * read_line - Reads a line of input from the user.
 *
 * Return: A pointer to the input line.
 */
char *read_line(void)
{
    char *line = NULL;
    size_t buffsize = 0;
    ssize_t chars_read;

    chars_read = getline(&line, &buffsize, stdin);

    if (chars_read == -1)
    {
        if (feof(stdin))
        {
            write(STDOUT_FILENO, "\n", 1);
            free(line);
            return (NULL);
        }
        else
        {
            perror("read_line");
            exit(EXIT_FAILURE);
        }
    }

    return (line);
}

/**
 * execute_command - Execute the given command.
 * @command: The command to execute.
 *
 * Description:
 * Executes the provided command using the fork and execve system
 * calls. It creates a child process to execute the command and waits
 * for the child process to complete. The function handles errors that
 * may arise during process creation and completion.
 */
void execute_command(char **args)
{
    pid_t child_pid, wait_pid;
    int status;

    child_pid = fork();

    if (child_pid == -1)
    {
        perror("fork");
        return;
    }

    if (child_pid == 0)
    {
        execve(args[0], args, NULL);
        perror("execve");
        exit(EXIT_FAILURE);
    }
    else
    {
        wait_pid = waitpid(child_pid, &status, 0);
        if (wait_pid == -1)
        {
            perror("waitpid");
        }
    }
}

/**
 * find_path - Finds the PATH environment variable.
 *
 * Return: A pointer to the PATH environment variable.
 */
char *find_path(char **envp)
{
    int i;

    for (i = 0; envp[i] != NULL; i++)
    {
        if (strncmp(envp[i], "PATH=", 5) == 0)
            return (envp[i] + 5);
    }

    return (NULL);
}

/**
 * check_command - Checks if a command exists in PATH.
 *
 * Return: A pointer to the full path of the command or NULL if not found.
 */
char *check_command(char **args, char **envp)
{
    char *path;
    char **dirs;
    char *full_path;
    int i;

    path = find_path(envp);

    if (!path)
        return (NULL);

    dirs = malloc(MAX_INPUT_SIZE * sizeof(char *));
    i = 0;
    dirs[i] = strtok(path, ":");

    while (dirs[i] != NULL)
    {
        i++;
        dirs[i] = strtok(NULL, ":");
    }

    for (i = 0; dirs[i] != NULL; i++)
    {
        full_path = malloc(MAX_INPUT_SIZE);
        snprintf(full_path, MAX_INPUT_SIZE, "%s/%s", dirs[i], args[0]);

        if (access(full_path, F_OK) == 0)
            return (full_path);

        free(full_path);
    }

    free(dirs);

   return (NULL);
}

int main(int argc __attribute__((unused)), char **argv __attribute__((unused)), char **envp)
{
   char *line;
   char **args;
   int i;

   while (1)
   {
       print_prompt();
       line = read_line();

       if (!line)
           break;

       if (strlen(line) > 0)
       {
           args = malloc(MAX_INPUT_SIZE * sizeof(char *));
           i = 0;
           args[i] = strtok(line, " \n");

           while (args[i] != NULL)
           {
               i++;
               args[i] = strtok(NULL, " \n");
           }
           args[i] = NULL;

           if (!check_command(args, envp))
               fprintf(stderr, "%s: command not found\n", args[0]);
           else
               execute_command(args);

           free(args);
       }

       free(line);
   }

   return (EXIT_SUCCESS);
}

